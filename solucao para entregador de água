import random
import math

# Função para calcular a distância entre dois pontos
def getDistancia(x1, y1, x2, y2):
    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

# Função para calcular o tempo de tolerância com base na distância
def calcularTolerancia(distancia):
    return distancia * 0.75

# Função para calcular a satisfação do cliente com base no tempo de entrega
def getSa7sfacao(tempo_tolerancia, tempo_entrega):
    atraso_percentual = (tempo_entrega - tempo_tolerancia) / tempo_tolerancia * 100

    if tempo_entrega <= tempo_tolerancia:
        return 6
    elif tempo_entrega < tempo_tolerancia / 2:
        return 10
    elif tempo_tolerancia / 2 <= tempo_entrega < tempo_tolerancia:
        return 8
    elif 0 < atraso_percentual <= 10:
        return 5
    elif 10 < atraso_percentual <= 20:
        return 4
    elif 20 < atraso_percentual <= 40:
        return 3
    elif 40 < atraso_percentual <= 60:
        return 2
    elif 60 < atraso_percentual <= 80:
        return 1
    else:
        return 0

# Função para calcular a satisfação total da rota
def calcSa7sfacao(arr_ordem, arr_posicoes, arr_pedido):
    carga_atual = 4
    tempo_atual = 0
    satisfacao_total = 0

    for i in range(len(arr_ordem)):
        cliente_atual = arr_ordem[i]
        x_atual, y_atual = arr_posicoes[cliente_atual]
        pedido_atual = arr_pedido[cliente_atual][1]

        if i > 0:
            x_anterior, y_anterior = arr_posicoes[arr_ordem[i-1]]
            distancia_anterior = getDistancia(x_anterior, y_anterior, x_atual, y_atual)
            tempo_atual += distancia_anterior * 0.5

        tempo_tolerancia = calcularTolerancia(getDistancia(0, 0, x_atual, y_atual))
        satisfacao_cliente = getSa7sfacao(tempo_tolerancia, tempo_atual)

        if pedido_atual > carga_atual:
            satisfacao_cliente -= 1  # Punir por não atender completamente o pedido

        satisfacao_total += satisfacao_cliente

        if cliente_atual == 0:  # Se for a sede, abastece a carga
            carga_atual = 4
        else:
            carga_atual -= pedido_atual

    return satisfacao_total

# Função de inicialização da população
def inicializar_populacao(num_individuos):
    return [list(range(1, len(arr_posicoes))) for _ in range(num_individuos)]

# Função de crossover (um ponto)
def crossover(pai1, pai2):
    ponto_corte = random.randint(0, len(pai1) - 1)
    filho1 = pai1[:ponto_corte] + [gene for gene in pai2 if gene not in pai1[:ponto_corte]]
    filho2 = pai2[:ponto_corte] + [gene for gene in pai1 if gene not in pai2[:ponto_corte]]
    return filho1, filho2

# Função de mutação (swap)
def mutacao(individuo):
    idx1, idx2 = random.sample(range(len(individuo)), 2)
    individuo[idx1], individuo[idx2] = individuo[idx2], individuo[idx1]
    return individuo

# Função de seleção de pais usando torneio
def selecao_torneio(populacao, fitness, tamanho_torneio):
    torneio = random.sample(range(len(populacao)), tamanho_torneio)
    vencedor = min(torneio, key=lambda i: fitness[i])
    return populacao[vencedor]

# Algoritmo Genético
def algoritmo_genetico(num_geracoes, tamanho_populacao, tamanho_torneio, taxa_crossover, taxa_mutacao):
    populacao = inicializar_populacao(tamanho_populacao)

    for geracao in range(num_geracoes):
        fitness = [calcSa7sfacao(individuo, arr_posicoes, arr_pedido) for individuo in populacao]

        nova_populacao = []

        # Elitismo - mantenha o melhor indivíduo
        melhor_individuo = populacao[fitness.index(max(fitness))]
        nova_populacao.append(melhor_individuo)

        # Crossover e mutação para gerar a nova população
        while len(nova_populacao) < tamanho_populacao:
            pai1 = selecao_torneio(populacao, fitness, tamanho_torneio)
            pai2 = selecao_torneio(populacao, fitness, tamanho_torneio)

            if random.random() < taxa_crossover:
                filho1, filho2 = crossover(pai1, pai2)
            else:
                filho1, filho2 = pai1[:], pai2[:]

            if random.random() < taxa_mutacao:
                filho1 = mutacao(filho1)
            if random.random() < taxa_mutacao:
                filho2 = mutacao(filho2)

            nova_populacao.extend([filho1, filho2])

        populacao = nova_populacao

    # Retorne o melhor indivíduo da última geração
    melhor_individuo = populacao[fitness.index(max(fitness))]
    return melhor_individuo, max(fitness)

# Exemplo de uso
arr_posicoes = [[10, 0], [1, 13], [30, 4]]
arr_pedido = [[1, 4], [3, 3], [2, 1]]

melhor_rota, melhor_fitness = algoritmo_genetico(num_geracoes=100, tamanho_populacao=50, tamanho_torneio=5,
                                                 taxa_crossover=0.8, taxa_mutacao=0.2)

print("Melhor Rota:", melhor_rota)
print("Melhor Fitness:", melhor_fitness)

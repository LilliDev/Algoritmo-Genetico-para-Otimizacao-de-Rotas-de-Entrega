import random
import math

# Função para calcular a distância entre dois pontos
def getDistancia(x1, y1, x2, y2):
    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

# Função para calcular o tempo de tolerância com base na distância
def calcularTolerancia(distancia):
    return distancia * 0.75

# Função para calcular a satisfação do cliente com base no tempo de entrega
def getSatisfacao(tempo_tolerancia, tempo_entrega):
    atraso_percentual = (tempo_entrega - tempo_tolerancia) / tempo_tolerancia * 100

    if tempo_entrega <= tempo_tolerancia:
        return 6
    elif tempo_entrega < tempo_tolerancia / 2:
        return 10
    elif tempo_tolerancia / 2 <= tempo_entrega < tempo_tolerancia:
        return 8
    elif 0 < atraso_percentual <= 10:
        return 5
    elif 10 < atraso_percentual <= 20:
        return 4
    elif 20 < atraso_percentual <= 40:
        return 3
    elif 40 < atraso_percentual <= 60:
        return 2
    elif 60 < atraso_percentual <= 80:
        return 1
    else:
        return 0

# Função para calcular a satisfação total da rota
def calcSatisfacao(arr_ordem, arr_posicoes, arr_pedido):
    carga_atual = 4
    tempo_atual = 0
    satisfacao_total = 0

    for i in range(len(arr_ordem)):
        cliente_atual = arr_ordem[i]
        x_atual, y_atual = arr_posicoes[cliente_atual]
        pedido_atual = arr_pedido[cliente_atual][1]

        if i > 0:
            x_anterior, y_anterior = arr_posicoes[arr_ordem[i-1]]
            distancia_anterior = getDistancia(x_anterior, y_anterior, x_atual, y_atual)
            tempo_atual += distancia_anterior * 0.5

        tempo_tolerancia = calcularTolerancia(getDistancia(0, 0, x_atual, y_atual))
        satisfacao_cliente = getSatisfacao(tempo_tolerancia, tempo_atual)

        if pedido_atual > carga_atual:
            satisfacao_cliente -= 1  # Punir por não atender completamente o pedido

        satisfacao_total += satisfacao_cliente

        if cliente_atual == 0:  # Se for a sede, abastece a carga
            carga_atual = 4
        else:
            carga_atual -= pedido_atual

    return satisfacao_total

# Função de inicialização da população
def inicializar_populacao(num_individuos):
    return [list(range(1, len(arr_posicoes))) for _ in range(num_individuos)]

# Função de crossover (um ponto)
def crossover(pai1, pai2):
    ponto_corte = random.randint(0, len(pai1) - 1)
    filho1 = pai1[:ponto_corte] + [gene for gene in pai2 if gene not in pai1[:ponto_corte]]
    filho2 = pai2[:ponto_corte] + [gene for gene in pai1 if gene not in pai2[:ponto_corte]]
    return filho1, filho2

# Função de mutação (swap)
def mutacao(individuo):
    idx1, idx2 = random.sample(range(len(individuo)), 2)
    individuo[idx1], individuo[idx2] = individuo[idx2], individuo[idx1]
    return individuo

# Função de seleção de pais usando torneio
def selecao_torneio(populacao, fitness, tamanho_torneio):
    torneio = random.sample(range(len(populacao)), tamanho_torneio)
    vencedor = min(torneio, key=lambda i: fitness[i])
    return populacao[vencedor]

# Algoritmo Genético
def algoritmo_genetico(num_geracoes, tamanho_populacao, tamanho_torneio, taxa_crossover, taxa_mutacao):
    populacao = inicializar_populacao(tamanho_populacao)

    for geracao in range(num_geracoes):
        fitness = [calcSatisfacao(individuo, arr_posicoes, arr_pedido) for individuo in populacao]

        nova_populacao = []

        # Elitismo - mantenha o melhor indivíduo
        melhor_individuo = populacao[fitness.index(max(fitness))]
        nova_populacao.append(melhor_individuo)

        # Crossover e mutação para gerar a nova população
        while len(nova_populacao) < tamanho_populacao:
            pai1 = selecao_torneio(populacao, fitness, tamanho_torneio)
            pai2 = selecao_torneio(populacao, fitness, tamanho_torneio)

            if random.random() < taxa_crossover:
                filho1, filho2 = crossover(pai1, pai2)
            else:
                filho1, filho2 = pai1[:], pai2[:]

            if random.random() < taxa_mutacao:
                filho1 = mutacao(filho1)
            if random.random() < taxa_mutacao:
                filho2 = mutacao(filho2)

            nova_populacao.extend([filho1, filho2])

        populacao = nova_populacao

    # Retorne o melhor indivíduo da última geração
    melhor_individuo = populacao[fitness.index(max(fitness))]
    return melhor_individuo, max(fitness)

# Exemplo de uso
arr_posicoes = [[10, 0], [1, 13], [30, 4]]
arr_pedido = [[1, 4], [3, 3], [2, 1]]

melhor_rota, melhor_fitness = algoritmo_genetico(num_geracoes=100, tamanho_populacao=50, tamanho_torneio=5,
                                                 taxa_crossover=0.8, taxa_mutacao=0.2)

print("Melhor Rota:", melhor_rota)
print("Melhor Fitness:", melhor_fitness)

sede = (0, 0)
base1 = [
    {"Leonardo": "Cliente A", "coordenadas": (1, 2), "pedidos": 2},
    {"Lillian": "Cliente B", "coordenadas": (5, 6), "pedidos": 1},
    {"Nicolas": "Cliente C", "coordenadas": (8, 3), "pedidos": 3},
    {"Juan": "Cliente D", "coordenadas": (3, 9), "pedidos": 2},
    {"Mamys": "Cliente E", "coordenadas": (6, 1), "pedidos": 1}
]

print("Base de Dados - Base 1:")
for cliente in base1:
    print(f"{cliente['nome']}: Coordenadas {cliente['coordenadas']}, Pedidos {cliente['pedidos']}")
    
sede = (0, 0)
base2 = [
    {"André": "Cliente1", "coordenadas": (2, 4), "pedidos": 3},
    {"Raquel": "Cliente 2", "coordenadas": (7, 5), "pedidos": 2},
    {"Jaque": "Cliente 3", "coordenadas": (1, 9), "pedidos": 1},
    {"Alicia": "Cliente 4", "coordenadas": (4, 3), "pedidos": 4},
    {"Marcia": "Cliente 5", "coordenadas": (8, 6), "pedidos": 2},
    {"Tom": "Cliente 6", "coordenadas": (6, 1), "pedidos": 3},
    {"Jane": "Cliente 7", "coordenadas": (3, 7), "pedidos": 1},
    {"Lucas": "Cliente 8", "coordenadas": (9, 2), "pedidos": 2},
    {"Black": "Cliente 9", "coordenadas": (5, 8), "pedidos": 1},
    {"Cariucha": "Cliente 10", "coordenadas": (2, 6), "pedidos": 3}
]

print("\nBase de Dados - Base 2:")
for cliente in base2:
    print(f"{cliente['nome']}: Coordenadas {cliente['coordenadas']}, Pedidos {cliente['pedidos']}")
    
sede = (0, 0)
base3 = [
    {"nome": f"Cliente {i}", "coordenadas": (random.randint(1, 10), random.randint(1, 10)), "pedidos": random.randint(1, 5)}
    for i in range(1, 31)
]

print("\nBase de Dados - Base 3:")
for cliente in base3:
    print(f"{cliente['nome']}: Coordenadas {cliente['coordenadas']}, Pedidos {cliente['pedidos']}")

clients =  [0,4,1,3,2,4,2,3,1,4,3,1,4,3,2,4,2,3,1,3,4,1,4,3,1,2,3,1,1,1,1]
print(len(clients))
#ordem das entregas
order_delivery = [0, 28, 7, 0, 27, 0, 8, 30, 0, 2, 10, 0, 27, 0, 13, 0, 2, 10, 0, 23, 7, 0, 8, 3, 0, 15, 0, 28, 14, 21, 8, 0, 9, 0, 28, 11, 0, 14, 28, 0, 29, 18, 0, 12]
#capacidade atual
capacity = 4
#clientes nao atendidos
no_served = []
#movimentos desnecessários
move_useless = 0
#cliente duplicado
duplicate_served = 0
duplicate_client = []
served = []

for i in range(0,len(order_delivery)):
    if(order_delivery[i] == 0 ):
        if(capacity == 4):
            move_useless+=1
        capacity = 4
    if(capacity >= clients[ order_delivery[i] ] ):
        capacity -= clients[ order_delivery[i] ]
        if(order_delivery[i]!=0 and order_delivery[i] in served):
            duplicate_served+=1
            duplicate_client.append( order_delivery[i] )
            
        served.append(order_delivery[i])
    else:
        no_served.append( order_delivery[i] )
        
print(len(no_served), " - clientes nao atendidos")
print( no_served )
print("movimento desnecessário")
print( move_useless )
print(duplicate_served, " - clientes atendidos em duplicidade")
print( duplicate_client )

